#Observer
观察者模式就是保留要通知对象的句柄（通知对象需要有更新对应状态的接口），在涉及状态改变的时候通知到具体的对象。

#Mediator
如果多个类的对象之间存在互相影响，可以创建一个中介类来负责处理这些交互，来封装对象之间的交互，减少耦合性。
实际上就是Observer的组合，负责多个观察者的协调和管理。
```c++
#include <iostream>
#include <memory>
#include <vector>

// 前向声明
class Colleague;

// 中介者接口
class Mediator {
   public:
    virtual void notify(std::shared_ptr<Colleague> sender,
                        const std::string &event) = 0;
};

// 同事接口
class Colleague : public std::enable_shared_from_this<Colleague> {
   protected:
    std::shared_ptr<Mediator> mediator;

   public:
    Colleague(std::shared_ptr<Mediator> mediator) : mediator(mediator) {}

    virtual void send(const std::string &event) {
        mediator->notify(shared_from_this(), event);
    }

    virtual void receive(const std::string &event) = 0;
};

// 具体的中介者
class ConcreteMediator : public Mediator {
   private:
    std::vector<std::shared_ptr<Colleague>> colleagues;

   public:
    void addColleague(std::shared_ptr<Colleague> colleague) {
        colleagues.push_back(colleague);
    }
    void notify(std::shared_ptr<Colleague> sender,
                const std::string &event) override {
        for (const auto &colleague : colleagues) {
            if (colleague != sender) {
                colleague->receive(event);
            }
        }
    }
};

// 具体的同事类
class ConcreteColleague : public Colleague {
   public:
    ConcreteColleague(std::shared_ptr<Mediator> mediator)
        : Colleague(mediator) {}

    void receive(const std::string &event) override {
        std::cout << "Colleague received: " << event << std::endl;
    }
};

// 主函数
int main() {
    auto mediator = std::make_shared<ConcreteMediator>();

    auto colleague1 = std::make_shared<ConcreteColleague>(mediator);
    auto colleague2 = std::make_shared<ConcreteColleague>(mediator);

    mediator->addColleague(colleague1);
    mediator->addColleague(colleague2);

    colleague1->send("Event from colleague 1");
    colleague2->send("Event from colleague 2");

    return 0;
}

```

#template
继承的时候需要有同样的对象属性（可以是定义、类型和动作），进行虚函数和覆写的操作。
并且尽可能将通用的动作（流程）进行更大程度的包装，减少暴露。

#status
额外添加一个表示状态的枚举变量，根据这个变量进行不同的动作。
如果需要保存对象状态，可以额外创建一个派生类对象来保存。


